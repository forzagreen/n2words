# CLAUDE.md - Project Context for AI Assistants

This document provides comprehensive context about the n2words project structure, patterns, and conventions to help AI assistants understand and work with the codebase effectively.

## Project Overview

**n2words** is a JavaScript library that converts numbers to words in 48 languages with zero dependencies.

- **Version**: 2.0.0
- **Type**: ES Module (ESM) with UMD browser bundles
- **Node.js**: >=20
- **License**: MIT
- **Zero dependencies**: Pure JavaScript implementation

### Key Features

- üåç 48 language implementations
- üì¶ Zero runtime dependencies
- üß™ Comprehensive testing and validation
- üì± Universal (Node.js, browsers, ESM/UMD)
- üî¢ Supports number, bigint, and string inputs
- üéØ Full TypeScript support via JSDoc annotations

### Supported Languages

The library supports 48 languages across multiple scripts and regional variants:

**European Languages (24):**
Croatian (hr), Czech (cs), Danish (da), Dutch (nl), English (en), French (fr), French Belgium (fr-BE), German (de), Greek (el), Hungarian (hu), Italian (it), Latvian (lv), Lithuanian (lt), Norwegian Bokm√•l (nb), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Serbian Cyrillic (sr-Cyrl), Serbian Latin (sr-Latn), Spanish (es), Swedish (sv), Turkish (tr), Ukrainian (uk)

**Asian & Middle Eastern Languages (24):**
Arabic (ar), Azerbaijani (az), Bangla/Bengali (bn), Filipino/Tagalog (fil), Gujarati (gu), Hebrew (he), Biblical Hebrew (hbo), Hindi (hi), Indonesian (id), Japanese (ja), Kannada (kn), Korean (ko), Malay (ms), Marathi (mr), Persian/Farsi (fa), Punjabi (pa), Simplified Chinese (zh-Hans), Swahili (sw), Tamil (ta), Telugu (te), Thai (th), Traditional Chinese (zh-Hant), Urdu (ur), Vietnamese (vi)

**Note:** 9 of the Asian languages are Indian subcontinent languages (Bangla, Gujarati, Hindi, Kannada, Marathi, Punjabi, Tamil, Telugu, Urdu) that use the SouthAsianLanguage base class with lakh/crore number system support.

**Languages with Options (21):**
Arabic, Biblical Hebrew, Croatian, Czech, Danish, Dutch, French, French Belgium, Hebrew, Latvian, Lithuanian, Polish, Romanian, Russian, Serbian Cyrillic, Serbian Latin, Simplified Chinese, Spanish, Traditional Chinese, Turkish, Ukrainian

See [Language-Specific Options](#3-language-specific-options) section for details on available options.

## Project Structure

```text
n2words/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ classes/              # Base classes for language implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ abstract-language.js          # Abstract base class (all languages inherit)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ greedy-scale-language.js      # Scale-based decomposition (most common)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ slavic-language.js            # Three-form pluralization (Slavic languages)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ south-asian-language.js       # Indian numbering system
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ turkic-language.js            # Turkish-style implicit "bir" rules
‚îÇ   ‚îú‚îÄ‚îÄ languages/            # Individual language implementations (48 files)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ en.js            # English
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ es.js            # Spanish
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ar.js            # Arabic (with options)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ zh-Hans.js       # Simplified Chinese (with options)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...              # 44 more languages
‚îÇ   ‚îî‚îÄ‚îÄ n2words.js            # Main entry point (exports all converters)
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ add-language.js       # Scaffolding tool for new languages
‚îÇ   ‚îú‚îÄ‚îÄ validate-language.js  # Validation tool for language implementations
‚îÇ   ‚îî‚îÄ‚îÄ README.md             # Scripts documentation
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îú‚îÄ‚îÄ fixtures/languages/   # Test data for each language (48 files)
‚îÇ   ‚îú‚îÄ‚îÄ unit/                 # Unit tests (class tests, edge cases)
‚îÇ   ‚îú‚îÄ‚îÄ integration/          # Integration tests (full conversion workflows)
‚îÇ   ‚îú‚îÄ‚îÄ types/                # TypeScript type checking tests
‚îÇ   ‚îî‚îÄ‚îÄ web/                  # Browser tests (Selenium: Chrome, Firefox)
‚îú‚îÄ‚îÄ bench/                    # Benchmark scripts (perf, memory)
‚îÇ   ‚îú‚îÄ‚îÄ perf.js               # Performance benchmark (uses benchmark.js)
‚îÇ   ‚îî‚îÄ‚îÄ memory.js             # Memory benchmark (requires --expose-gc)
‚îú‚îÄ‚îÄ dist/                     # UMD browser bundles (generated by rollup)
‚îÇ   ‚îú‚îÄ‚îÄ n2words.js            # Main bundle - all 48 converters (~92KB, ~23KB gzipped)
‚îÇ   ‚îú‚îÄ‚îÄ {ConverterName}.js    # 48 individual converter bundles (~4-6KB each)
‚îÇ   ‚îî‚îÄ‚îÄ *.js.map              # Source maps for all bundles
‚îú‚îÄ‚îÄ rollup.config.js          # Bundling config for UMD/dist builds
‚îú‚îÄ‚îÄ .browserslistrc           # Browser targeting ("defaults and supports bigint")
‚îî‚îÄ‚îÄ .nvmrc                    # Node version (lts/*)
```

## Core Architecture

### 1. Class Hierarchy

All language implementations follow an inheritance pattern:

```text
AbstractLanguage (base)
‚îú‚îÄ‚îÄ GreedyScaleLanguage    # Most common: English, Spanish, French, etc.
‚îú‚îÄ‚îÄ SlavicLanguage         # Russian, Polish, Czech, etc.
‚îú‚îÄ‚îÄ SouthAsianLanguage     # Hindi, Tamil, Telugu, Bengali, etc.
‚îî‚îÄ‚îÄ TurkicLanguage         # Turkish, Azerbaijani
```

#### AbstractLanguage (base class)

**Responsibilities:**

- Validates and normalizes input (`number | string | bigint`)
- Splits into sign, whole, and decimal parts
- Handles negative numbers (prepends `negativeWord`)
- Converts decimal parts
- Delegates whole number conversion to `convertWholePart()`

**Required properties subclasses must provide:**

```javascript
negativeWord = ''           // Word for negative (e.g., "minus")
zeroWord = ''              // Word for zero
decimalSeparatorWord = ''  // Word between whole and decimal (e.g., "point")
wordSeparator = ' '        // Separator between words
```

**Required methods subclasses must implement:**

```javascript
convertWholePart(wholeNumber) // bigint ‚Üí string
```

**Optional properties:**

```javascript
convertDecimalsPerDigit = false  // true = digit-by-digit decimals
digits = null                    // Array of digit words for lookup
```

#### GreedyScaleLanguage

**Used by**: English, Spanish, French, German, Arabic, Italian, Portuguese, etc. (most languages)

**How it works:**

1. Defines `scaleWordPairs` array: `[[value, word], ...]` in descending order
2. Greedily decomposes numbers using largest scale first
3. Calls `mergeScales(leftWords, leftScale, rightWords, rightScale)` to combine parts

**Example implementation pattern:**

```javascript
export class English extends GreedyScaleLanguage {
  negativeWord = 'minus'
  zeroWord = 'zero'
  decimalSeparatorWord = 'point'

  scaleWordPairs = [
    [1000000000n, 'billion'],
    [1000000n, 'million'],
    [1000n, 'thousand'],
    [100n, 'hundred'],
    [90n, 'ninety'],
    // ... down to 1n
  ]

  mergeScales(leftWords, leftScale, rightWords, rightScale) {
    // Language-specific merge logic
    if (leftScale === 100n && rightScale < 100n) {
      return leftWords + ' and ' + rightWords
    }
    return leftWords + ' ' + rightWords
  }
}
```

#### SlavicLanguage

**Used by**: Russian, Polish, Czech, Croatian, Serbian (both Cyrillic and Latin), Ukrainian, Lithuanian, Latvian

**Key feature**: Three-form pluralization based on number endings, optional gender support

**Pattern:**

```javascript
export class Russian extends SlavicLanguage {
  pluralForms = {
    1: ['—Ç—ã—Å—è—á–∞', '—Ç—ã—Å—è—á–∏', '—Ç—ã—Å—è—á'],       // 10^3 (chunk index 1)
    2: ['–º–∏–ª–ª–∏–æ–Ω', '–º–∏–ª–ª–∏–æ–Ω–∞', '–º–∏–ª–ª–∏–æ–Ω–æ–≤'], // 10^6 (chunk index 2)
    3: ['–º–∏–ª–ª–∏–∞—Ä–¥', '–º–∏–ª–ª–∏–∞—Ä–¥–∞', '–º–∏–ª–ª–∏–∞—Ä–¥–æ–≤'] // 10^9 (chunk index 3)
  }

  // Keys are chunk indices: 1 = thousands, 2 = millions, 3 = billions, etc.
  // Automatically selects correct form based on number
}
```

#### SouthAsianLanguage

**Used by**: Hindi, Tamil, Telugu, Bengali, Gujarati, Kannada, Marathi, Punjabi, Urdu

**Key feature**: Supports Indian numbering system (lakh, crore)

#### TurkicLanguage

**Used by**: Turkish, Azerbaijani

**Key feature**: Omits "bir" (one) before certain scales

### 2. Entry Point Structure ([lib/n2words.js](lib/n2words.js))

The main file is organized into clear sections:

```javascript
// ============================================================================
// Language Imports
// ============================================================================
import { Arabic } from './languages/ar.js'
import { English } from './languages/en.js'
// ... (alphabetically sorted)

// ============================================================================
// Type Definitions
// ============================================================================
/** @typedef {number | bigint | string} NumericValue */
/** @typedef {Object} ArabicOptions ... */
// ... (alphabetically sorted by language)

// ============================================================================
// Converter Factory
// ============================================================================
function makeConverter (LanguageClass) {
  return function convertToWords (value, options = {}) {
    return new LanguageClass(options).convertToWords(value)
  }
}

// ============================================================================
// Language Converters
// ============================================================================
const ArabicConverter = /** @type {(value: NumericValue, options?: ArabicOptions) => string} */ (makeConverter(Arabic))
const EnglishConverter = /** @type {(value: NumericValue) => string} */ (makeConverter(English))
// ... (alphabetically sorted)

// ============================================================================
// Exports
// ============================================================================
export {
  ArabicConverter,
  EnglishConverter,
  // ... (alphabetically sorted)
}
```

**IMPORTANT PATTERNS:**

- All imports, converters, and exports are **alphabetically sorted**
- Languages with options have type annotations: `options?: LanguageOptions`
- Languages without options: `(value: NumericValue) => string`
- Each section is clearly marked with comment headers

### 3. Language-Specific Options

Some languages support additional options:

| Language         | Option                | Type                            | Description                           |
| ---------------- | --------------------- | ------------------------------- | ------------------------------------- |
| Arabic           | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Arabic           | `negativeWord`        | string                          | Custom negative word                  |
| Biblical Hebrew  | `andWord`             | string                          | Conjunction character (default: '◊ï')  |
| Biblical Hebrew  | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Chinese (both)   | `formal`              | boolean                         | Formal/financial vs common numerals   |
| Croatian         | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Czech            | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Danish           | `ordFlag`             | boolean                         | Enable ordinal number conversion      |
| Dutch            | `includeOptionalAnd`  | boolean                         | Include optional "en" separator       |
| Dutch            | `noHundredPairs`      | boolean                         | Disable comma before hundreds         |
| Dutch            | `accentOne`           | boolean                         | Use accented "√©√©n" for one            |
| French           | `withHyphenSeparator` | boolean                         | Use hyphens vs spaces                 |
| French Belgium   | `withHyphenSeparator` | boolean                         | Use hyphens vs spaces                 |
| Hebrew           | `andWord`             | string                          | Conjunction character (default: '◊ï')  |
| Latvian          | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Lithuanian       | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Polish           | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Romanian         | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Russian          | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Serbian Cyrillic | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Serbian Latin    | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Spanish          | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |
| Turkish          | `dropSpaces`          | boolean                         | Remove spaces between words           |
| Ukrainian        | `gender`              | 'masculine' \| 'feminine'       | Grammatical gender for number forms   |

**Typedef pattern for options:**

```javascript
/**
 * @typedef {Object} ArabicOptions
 * @property {string} [negativeWord] Word for negative numbers
 * @property {('masculine'|'feminine')} [gender='masculine'] Grammatical gender for number forms
 */
```

## Development Workflows

### Available npm Scripts

The project provides comprehensive npm scripts for all development tasks:

**Testing:**

- `npm test` - Full test suite (validation + unit + integration + types)
- `npm run test:all` - All tests including browser tests
- `npm run test:unit` - Unit tests only
- `npm run test:integration` - Integration tests only
- `npm run test:types` - TypeScript type checking
- `npm run test:web` - Browser tests (requires build first)
- `npm run test:minimal` - Minimal test suite (unit + integration, no validation)
- `npm run coverage` - Generate test coverage report

**Language Development:**

- `npm run lang:add <code>` - Scaffold a new language implementation
- `npm run lang:validate` - Validate all language implementations
- `npm run lang:validate -- <codes>` - Validate specific languages
- `npm run lang:validate -- --verbose` - Detailed validation output

**Building:**

- `npm run build` - Generate all UMD bundles in dist/

**Code Quality:**

- `npm run lint` - Lint all (JavaScript + Markdown)
- `npm run lint:fix` - Auto-fix all linting issues
- `npm run lint:js` - Lint JavaScript only
- `npm run lint:js:fix` - Auto-fix JavaScript only
- `npm run lint:md` - Lint Markdown only
- `npm run lint:md:fix` - Auto-fix Markdown only

**Compatibility:**

- `npm run browsers` - Show targeted browser versions
- `npm run browsers:coverage` - Show global browser coverage
- `npm run compat:node` - Verify lib/ is ES2022 compatible
- `npm run compat:web` - Verify dist/ bundles ES version

**Benchmarking:**

- `npm run bench:perf` - Performance benchmarks
- `npm run bench:memory` - Memory usage benchmarks

### Adding a New Language

Use the scaffolding tool:

```bash
npm run lang:add <language-code>
```

**What it does:**

1. Validates language code (IETF BCP 47 format: `en`, `zh-Hans`, `fr-BE`)
2. Creates `lib/languages/{code}.js` with boilerplate
3. Creates `test/fixtures/languages/{code}.js` with test cases
4. Updates `lib/n2words.js`:
   - Adds import (alphabetically in Language Imports section)
   - Creates converter with type annotation (alphabetically in Language Converters section)
   - Adds export (alphabetically in Exports section)

**After scaffolding:**

1. Edit `lib/languages/{code}.js`:
   - Replace placeholder words
   - Add complete `scaleWordPairs` array
   - Implement `mergeScales()` logic
2. Edit `test/fixtures/languages/{code}.js`:
   - Add comprehensive test cases
3. Validate: `npm run lang:validate -- {code} --verbose`
4. Test: `npm test`

### Validating Languages

```bash
npm run lang:validate              # All languages
npm run lang:validate -- en es fr  # Specific languages
npm run lang:validate -- --verbose # Detailed info
```

**What it validates:**

- ‚úÖ IETF BCP 47 naming convention
- ‚úÖ Class structure and inheritance
- ‚úÖ Required properties (negativeWord, zeroWord, etc.)
- ‚úÖ Method implementations (convertWholePart)
- ‚úÖ Scale word ordering (descending)
- ‚úÖ Import/converter/export in n2words.js
- ‚úÖ Test fixture exists
- ‚úÖ JSDoc documentation

**Exit codes:**

- 0: All validations passed
- 1: One or more languages have errors

### Testing

```bash
npm test                 # Full test suite (validation + unit + integration + types)
npm run test:unit        # Unit tests only
npm run test:integration # Integration tests only
npm run test:types       # TypeScript type checking
npm run test:web         # Browser tests (Chrome, Firefox via Selenium on dist/)
npm run test:all         # All tests including web tests
```

**IMPORTANT - Browser Testing:**

- Browser tests (`test:web`) run against **`dist/` UMD bundles**, not `lib/` source
- These tests verify actual browser compatibility (Chrome 67+, Firefox 68+, Safari 14+, Edge 79+)
- Browser compatibility claims are based on these `dist/` bundle tests
- The `lib/` source is ES2022+ and is intended for modern bundlers, not direct browser usage

### Compatibility Verification

```bash
# Browser compatibility
npm run browsers            # Show targeted browser versions
npm run browsers:coverage   # Show global browser coverage (~86%)
npm run compat:web          # Verify dist/ bundle compatibility (ES version check)
npm run test:web            # Test in real browsers (Chrome, Firefox)

# Node.js compatibility
npm run compat:node         # Verify lib/ source is ES2022 compatible
```

**Node.js Version Management:**

- Minimum required: Node.js 20+ (specified in `package.json` engines field: `>=20`)
- Recommended: Use `.nvmrc` (set to `lts/*`) for automatic version selection with nvm/fnm
- Verification: Run `node --version` and ensure it's 20 or above

### Build & Bundling

```bash
npm run build        # Generate all dist/ bundles (main + 48 individual converters)
```

- **Tooling:** `rollup` (configured in [rollup.config.js](rollup.config.js)) generates UMD bundles in `dist/`.
- **Outputs:**
  - `dist/n2words.js` - Main bundle with all 48 converters (~92KB, ~23KB gzipped)
  - `dist/{ConverterName}.js` - Individual converter UMD files (48 files, ~4-6KB each)
  - `dist/*.js.map` - Source maps for all bundles (49 total files + 49 source maps)
- **Babel:** `@babel/preset-env` is used with targets from [.browserslistrc](.browserslistrc) (`defaults and supports bigint`). The build is configured to keep `BigInt` primitives in the output (no polyfill for BigInt).
- **Minification:** `terser` with `ecma: 2020` is used for minification with 2-pass compression.
- **Banner:** Builds include a versioned banner using `package.json` `version` and MIT license notice.
- **Tree-shaking:** Individual converter bundles use tree-shaking to include only the specific converter and its dependencies.

**Note**: BigInt is a hard runtime requirement for the library; legacy engines without BigInt (e.g., IE11) are not supported by the distributed UMD bundles.

**Two Build Targets:**

1. **`dist/` (UMD bundles)**: For direct browser usage via CDN/`<script>` tags
   - Transpiled with Babel to ES2020 (preserving BigInt)
   - Tested in real browsers (Chrome, Firefox via Selenium)
   - Browser compatibility: Chrome 67+, Firefox 68+, Safari 14+, Edge 79+

2. **`lib/` (ESM source)**: For modern bundlers (Webpack, Vite, Rollup) and Node.js
   - ES2022+ modern JavaScript (class fields, BigInt, optional chaining, etc.)
   - Requires bundler/transpilation for browser compatibility
   - Smaller final bundles with tree-shaking

### Code Quality

```bash
npm run lint         # Lint all (JS + Markdown)
npm run lint:js      # JavaScript linting (StandardJS)
npm run lint:md      # Markdown linting
npm run lint:fix     # Auto-fix both
npm run lint:js:fix  # Auto-fix JavaScript only
npm run lint:md:fix  # Auto-fix Markdown only
```

## Important Conventions

### 1. Language Code Format

**ALWAYS use IETF BCP 47 format:**

- Base: `en`, `fr`, `es` (2-3 lowercase letters)
- Script: `zh-Hans`, `sr-Latn` (language-Script)
- Region: `fr-BE`, `en-US` (language-REGION)

**File naming:**

- Language file: `lib/languages/{code}.js` (e.g., `en.js`, `zh-Hans.js`)
- Test fixture: `test/fixtures/languages/{code}.js`

### 2. Class Naming

**Use CLDR Display Names in PascalCase:**

- `en` ‚Üí `English`
- `zh-Hans` ‚Üí `SimplifiedChinese`
- `fr-BE` ‚Üí `FrenchBelgium`
- `sr-Latn` ‚Üí `SerbianLatin`
- `nb` ‚Üí `NorwegianBokmal`

**Get canonical name:**

```javascript
const displayNames = new Intl.DisplayNames(['en'], { type: 'language' })
displayNames.of('zh-Hans') // "Simplified Chinese"
```

**Exception**: Rare/historical languages not in CLDR (e.g., `hbo` - Biblical Hebrew) use descriptive names.

### 3. Alphabetical Ordering

**CRITICAL**: All lists in `lib/n2words.js` MUST be alphabetically sorted:

- Imports
- Type definitions
- Converter declarations
- Exports

**Why**: Makes maintenance easier, reduces merge conflicts, aids readability.

### 4. Type Annotations

**Languages with options:**

```javascript
const ArabicConverter = /** @type {(value: NumericValue, options?: ArabicOptions) => string} */ (makeConverter(Arabic))
```

**Languages without options:**

```javascript
const EnglishConverter = /** @type {(value: NumericValue) => string} */ (makeConverter(English))
```

**Always define options typedef:**

```javascript
/**
 * @typedef {Object} ArabicOptions
 * @property {string} [negativeWord] Word for negative numbers
 * @property {('masculine'|'feminine')} [gender='masculine'] Grammatical gender for number forms
 */
```

### 5. Test Fixtures

**Format:**

```javascript
export default [
  [input, expectedOutput],
  [input, expectedOutput, options],

  // Examples:
  [0, 'zero'],
  [42, 'forty-two'],
  [-1, 'minus one'],
  [3.14, 'three point one four'],
  [BigInt(999), 'nine hundred and ninety-nine'],
  [1, 'Ÿàÿßÿ≠ÿØÿ©', { gender: 'feminine' }]  // With options
]
```

### 6. Documentation

**Class-level JSDoc:**

```javascript
/**
 * English language converter.
 *
 * Converts numbers to English words, supporting:
 * - Negative numbers (prepended with "minus")
 * - Decimal numbers ("point" separator)
 * - Large numbers (up to billions)
 *
 * Examples:
 * - 42 ‚Üí "forty-two"
 * - 123 ‚Üí "one hundred and twenty-three"
 * - -3.14 ‚Üí "minus three point one four"
 */
export class English extends GreedyScaleLanguage {
  // ...
}
```

**Method-level JSDoc:**

```javascript
/**
 * Merges scale components with appropriate separators.
 *
 * @param {string} leftWords - Words for the left (higher scale) component
 * @param {bigint} leftScale - The scale value of the left component
 * @param {string} rightWords - Words for the right (lower scale) component
 * @param {bigint} rightScale - The scale value of the right component
 * @returns {string} The merged result
 */
mergeScales(leftWords, leftScale, rightWords, rightScale) {
  // ...
}
```

## Common Patterns

### Pattern 1: Basic Scale-Based Language

```javascript
import { GreedyScaleLanguage } from '../classes/greedy-scale-language.js'

export class MyLanguage extends GreedyScaleLanguage {
  negativeWord = 'minus'
  zeroWord = 'zero'
  decimalSeparatorWord = 'point'

  scaleWordPairs = [
    [1000000n, 'million'],
    [1000n, 'thousand'],
    [100n, 'hundred'],
    // ... complete list down to 1n
  ]

  mergeScales(leftWords, leftScale, rightWords, rightScale) {
    return leftWords + ' ' + rightWords
  }
}
```

### Pattern 2: Language with Gender Options

```javascript
export class MyLanguage extends GreedyScaleLanguage {
  constructor(options = {}) {
    super()

    this.options = this.mergeOptions({
      gender: 'masculine'
    }, options)
  }

  get scaleWordPairs() {
    // Return appropriate scale words based on gender
    return this.options.gender === 'feminine'
      ? this.feminineScales
      : this.masculineScales
  }

  masculineScales = [/* masculine forms */]
  feminineScales = [/* feminine forms */]
}
```

### Pattern 3: Regional Variant

```javascript
import { French } from './fr.js'

export class FrenchBelgium extends French {
  constructor(options = {}) {
    super(options)
    // Override specific scale words
    this.updateScaleWord(70n, 'septante')
    this.updateScaleWord(90n, 'nonante')
  }
}
```

## Scripts Deep Dive

### add-language.js

**Purpose**: Scaffold a new language implementation

**Usage:**

```bash
npm run lang:add <language-code>
# Example: npm run lang:add ko
# Example: npm run lang:add zh-Hans
```

**Key functions:**

- `validateLanguageCode(code)` - Validates IETF BCP 47 format
- `getExpectedClassName(code)` - Gets CLDR-based class name using `Intl.DisplayNames`
- `generateLanguageFile(className)` - Creates language file template
- `generateTestFixture(code)` - Creates test fixture template
- `updateN2wordsFile(code, className)` - Updates main entry point

**What it generates:**

1. `lib/languages/{code}.js` - Language implementation with boilerplate
2. `test/fixtures/languages/{code}.js` - Test fixture template
3. Updates to `lib/n2words.js` (import, converter, export)

**Important**: Maintains alphabetical ordering in all sections

### validate-language.js

**Purpose**: Validate language implementations for correctness and completeness

**Usage:**

```bash
npm run lang:validate              # Validate all 48 languages
npm run lang:validate -- en es fr  # Validate specific languages
npm run lang:validate -- --verbose # Show detailed validation info
```

**Validation checks:**

1. File naming (IETF BCP 47 compliance)
2. Class structure (proper ES6 class with export)
3. CLDR class naming (matches `Intl.DisplayNames` output)
4. Required properties exist and have correct types
5. Methods implemented (not abstract/missing)
6. Inheritance from valid base class
7. Scale words properly ordered (descending for GreedyScaleLanguage)
8. JSDoc documentation present and complete
9. Test fixture exists and properly formatted
10. Registered in n2words.js (import, converter, export - all alphabetically sorted)

**Pure functions** (can be imported):

- `validateLanguageCode(code)` - Validates IETF BCP 47 format
- `getExpectedClassName(code)` - Gets expected CLDR-based class name
- `validateLanguage(code)` - Validates a single language implementation

**Exit codes:**

- `0`: All validations passed
- `1`: One or more validations failed

## Performance Considerations

### Best Practices

1. **BigInt arithmetic**: Use `BigInt` for all scale values to support large numbers
2. **Greedy algorithm**: Most efficient for scale-based decomposition
3. **Caching**: AbstractLanguage caches whole number for reuse
4. **Zero dependencies**: No external libraries, minimal overhead

### Bundle Size

- **Main UMD bundle** (`dist/n2words.js`): ~92 KB minified (~23 KB gzipped) - all 48 languages
- **Individual converter bundles** (`dist/{ConverterName}.js`): ~4-6 KB each minified
- **ESM source** (`lib/`): Tree-shaking supported - import only what you need for optimal bundle size
- **Per-language overhead**: ~2 KB gzipped per language when using ESM with tree-shaking

## Testing Strategy

### Unit Tests

Located in `test/unit/` - test individual class methods and edge cases.

### Integration Tests

Located in `test/integration/` - test full conversion workflows using fixtures.

**Pattern:**

```javascript
import test from 'ava'
import { EnglishConverter } from 'n2words'
import fixtures from '../fixtures/languages/en.js'

for (const [input, expected, options] of fixtures) {
  test(`${input} ‚Üí ${expected}`, t => {
    t.is(EnglishConverter(input, options), expected)
  })
}
```

### Web Tests

Located in `test/web/` - test browser builds (UMD) using Selenium.

## TypeScript Support

**Method**: JSDoc annotations (not TypeScript source)

**Benefits:**

- Works in both JS and TS projects
- IntelliSense in VSCode
- Type checking without compilation
- Smaller package size (no .d.ts files needed)

**Type exports:**

```typescript
import type { NumericValue, ArabicOptions } from 'n2words'
```

## Benchmarking

The project includes performance and memory benchmarking tools:

```bash
npm run bench:perf    # Run performance benchmarks
npm run bench:memory  # Run memory usage benchmarks (requires --expose-gc flag)
```

**Performance benchmarks** ([bench/perf.js](bench/perf.js)):

- Uses `benchmark.js` library for accurate measurements
- Tests conversion speed across different number ranges
- Compares performance across multiple languages
- Outputs operations per second (ops/sec)

**Memory benchmarks** ([bench/memory.js](bench/memory.js)):

- Requires Node.js `--expose-gc` flag (already configured in npm script)
- Measures heap usage before/after conversions
- Tests memory efficiency across languages
- Helps identify memory leaks or excessive allocations

## Key Files Reference

| File                                   | Purpose                                         |
| -------------------------------------- | ----------------------------------------------- |
| `lib/n2words.js`                       | Main entry point, exports all converters        |
| `lib/classes/abstract-language.js`     | Base class, input validation, decimal handling  |
| `lib/classes/greedy-scale-language.js` | Scale-based decomposition strategy              |
| `lib/classes/slavic-language.js`       | Three-form pluralization for Slavic languages   |
| `lib/classes/south-asian-language.js`  | Indian numbering system (lakh, crore)           |
| `lib/classes/turkic-language.js`       | Turkish-style implicit "bir" handling           |
| `lib/languages/*.js`                   | Individual language implementations (48 files)  |
| `scripts/add-language.js`              | Scaffolding tool for new languages              |
| `scripts/validate-language.js`         | Validation tool for language implementations    |
| `bench/perf.js`                        | Performance benchmark script                    |
| `bench/memory.js`                      | Memory usage benchmark script                   |
| `test/fixtures/languages/*.js`         | Test data for each language (48 files)          |
| `test/unit/*.js`                       | Unit tests for classes and methods              |
| `test/integration/*.js`                | Integration tests using fixtures                |
| `test/web/*.js`                        | Browser tests using Selenium                    |
| `test/types/*.js`                      | TypeScript type checking tests                  |
| `rollup.config.js`                     | Build configuration for UMD bundles             |
| `.browserslistrc`                      | Browser targeting configuration                 |
| `.nvmrc`                               | Node.js version specification (lts/*)           |
| `package.json`                         | Scripts, dependencies, metadata, config         |

## Common Issues & Solutions

### Issue: Validation fails with "not imported in n2words.js"

**Solution**: Ensure three entries in `lib/n2words.js`:

1. Import in Language Imports section
2. Converter with type annotation in Language Converters section
3. Export in Exports section

All must be **alphabetically sorted** within their sections.

### Issue: "scaleWordPairs not in descending order"

**Solution**: Scale words MUST be ordered from largest to smallest:

```javascript
scaleWordPairs = [
  [1000000n, 'million'],  // Largest first
  [1000n, 'thousand'],
  [100n, 'hundred'],
  [1n, 'one']            // Smallest last
]
```

### Issue: "convertWholePart() not implemented"

**Solution**: Subclass must implement this abstract method:

```javascript
convertWholePart(wholeNumber) {
  if (wholeNumber === 0n) return this.zeroWord
  // Implementation here
}
```

For GreedyScaleLanguage, this is auto-implemented if `scaleWordPairs` and `mergeScales` are provided.

## Contributing Guidelines

1. **Add new language**: Use `npm run lang:add <code>`
2. **Validate**: `npm run lang:validate -- <code> --verbose`
3. **Test**: `npm test`
4. **Lint**: `npm run lint:fix`
5. **Document**: Add JSDoc comments
6. **Keep alphabetical**: All lists in n2words.js must stay sorted

## Resources

- IETF BCP 47: <https://tools.ietf.org/html/bcp47>
- CLDR Language Names: Uses `Intl.DisplayNames` API
- Language Codes Lookup: <https://en.wikipedia.org/wiki/IETF_language_tag>

---

**Last Updated**: 2025-12-26
**Project Version**: 2.0.0
**Maintained By**: Tyler Vigario & contributors

## Additional Resources

### Package Distribution

- **npm**: `npm install n2words`
- **CDN (jsDelivr)**: `https://cdn.jsdelivr.net/npm/n2words@2/dist/n2words.js`
- **CDN (unpkg)**: `https://unpkg.com/n2words@2/dist/n2words.js`

### Coverage Metrics

- **Browser Coverage**: ~86% of global users (via browserslist query: "defaults and supports bigint")
- **Test Coverage**: Comprehensive unit, integration, and browser tests for all 48 languages
- **Type Coverage**: Full JSDoc annotations for TypeScript IntelliSense

### Development Dependencies

The project uses modern development tools:

- **Testing**: AVA (test runner), Selenium WebDriver (browser tests)
- **Build**: Rollup (bundler), Babel (transpiler), Terser (minifier)
- **Quality**: Standard (linter), Markdownlint (markdown), c8 (coverage)
- **Benchmarking**: benchmark.js (performance), microtime (precision timing)

### Project Metadata

- **Package**: `n2words`
- **Repository**: `https://github.com/forzagreen/n2words`
- **Issues**: `https://github.com/forzagreen/n2words/issues`
- **Original Author**: Wael TELLAT
- **Contributors**: Tyler Vigario and community contributors
- **Package Type**: ES Module (`"type": "module"`)
- **Side Effects**: None (`"sideEffects": false` - safe for tree-shaking)
