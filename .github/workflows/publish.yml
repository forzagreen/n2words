name: Publish

env:
  HUSKY: 0
  CI: true

on:
  push:
    tags:
      - v*

concurrency:
  group: publish-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  # Wait for CI to pass before publishing
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      actions: read
    outputs:
      ci-success: ${{ steps.check.outputs.success }}

    steps:
      - name: Wait for CI checks on tag commit
        uses: actions/github-script@v8.0.0
        id: check
        with:
          script: |
            const tagName = context.ref.replace('refs/tags/', '');
            console.log(`Checking CI checks for tag: ${tagName}`);

            // Resolve tag -> commit SHA (handles annotated and lightweight tags)
            const { data: tagRef } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `tags/${tagName}`
            });

            let commitSha = tagRef.object.sha;
            if (tagRef.object.type === 'tag') {
              const { data: annotatedTag } = await github.rest.git.getTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_sha: tagRef.object.sha
              });
              commitSha = annotatedTag.object.sha;
            }

            console.log(`Resolved commit SHA: ${commitSha}`);

            // Poll the Checks API for the commit's check suites (max 30 minutes)
            const maxAttempts = 60;
            const delayMs = 30000; // 30s

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              console.log(`Attempt ${attempt}/${maxAttempts}: checking check suites for ${commitSha}`);

              const { data: suitesData } = await github.rest.checks.listSuitesForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: commitSha,
                per_page: 100
              });

              if (suitesData.total_count > 0) {
                console.log(`Found ${suitesData.total_count} check suite(s)`);

                // Look for any completed suite with a successful conclusion
                const succeeded = suitesData.check_suites.find(s => s.status === 'completed' && s.conclusion === 'success');
                if (succeeded) {
                  console.log('‚úÖ Checks passed for commit. Proceeding with publish.');
                  core.setOutput('success', 'true');
                  return;
                }

                // If any suite completed with non-success conclusion, fail fast
                const failedSuite = suitesData.check_suites.find(s => s.status === 'completed' && s.conclusion && s.conclusion !== 'success');
                if (failedSuite) {
                  core.setFailed(`‚ùå Checks completed but failed (conclusion=${failedSuite.conclusion})`);
                  return;
                }
              } else {
                console.log('No check suites found for this commit yet.');
              }

              if (attempt < maxAttempts) {
                console.log(`Waiting ${delayMs/1000}s before next check...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
              }
            }

            // Fallback: try matching workflow runs for the ci workflow by comparing head_sha/head_commit
            console.log('‚è≥ Timeout waiting for check suites; falling back to workflow-run matching. Applying tighter filters (time window + event).');

            // Derive a time window around the commit to avoid matching unrelated old runs.
            const { data: commitInfo } = await github.rest.repos.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: commitSha
            });
            const commitDate = new Date(commitInfo.commit.author.date || commitInfo.commit.committer.date);
            const windowHours = 24; // restrict to runs within this many hours of the commit
            const fromTs = new Date(commitDate.getTime() - windowHours * 3600 * 1000);
            const toTs = new Date(commitDate.getTime() + windowHours * 3600 * 1000);
            console.log(`Looking for runs between ${fromTs.toISOString()} and ${toTs.toISOString()}`);

            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              per_page: 100
            });

            if (runs.total_count > 0) {
              // Allowed triggering events for CI validation
              const allowedEvents = new Set(['push', 'workflow_dispatch']);

              const candidate = runs.workflow_runs.find(r => {
                // basic sha match
                const shaMatch = r.head_sha === commitSha || (r.head_commit && r.head_commit.id === commitSha);
                if (!shaMatch) return false;

                // event filter
                if (!allowedEvents.has(r.event)) {
                  console.log(`Rejecting run ${r.id} due to event=${r.event}`);
                  return false;
                }

                // created_at within window
                const created = new Date(r.created_at);
                if (created < fromTs || created > toTs) {
                  console.log(`Rejecting run ${r.id} due to created_at=${r.created_at} outside window`);
                  return false;
                }

                // only accept completed runs here
                if (r.status !== 'completed') {
                  console.log(`Skipping run ${r.id} with status=${r.status}`);
                  return false;
                }

                return true;
              });

              if (candidate) {
                console.log(`Found candidate workflow run ${candidate.id}: conclusion=${candidate.conclusion}, event=${candidate.event}, created_at=${candidate.created_at}`);
                if (candidate.conclusion === 'success') {
                  core.setOutput('success', 'true');
                  return;
                }
                core.setFailed(`‚ùå CI failed with conclusion: ${candidate.conclusion}`);
                return;
              }
            }

            core.setFailed('‚è±Ô∏è Timeout: CI checks/workflow run not completed or not found for the tag commit (after applying tighter fallback filters)');

  publish:
    name: Publish to npm
    needs: check-ci
    if: needs.check-ci.outputs.ci-success == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
      id-token: write

    steps:
      - uses: actions/checkout@v6.0.1
        with:
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v6.1.0
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'
          cache: 'npm'

      - name: Validate version matches tag
        id: version
        run: |
          PKG_VERSION="v$(node -p "require('./package.json').version")"
          TAG_VERSION="${GITHUB_REF#refs/tags/}"
          if [ "$PKG_VERSION" != "$TAG_VERSION" ]; then
            echo "‚ùå Error: package.json version ($PKG_VERSION) does not match tag ($TAG_VERSION)"
            exit 1
          fi
          echo "‚úÖ Version validated: $PKG_VERSION"
          echo "version=$PKG_VERSION" >> $GITHUB_OUTPUT

      - name: Verify git tag signature
        run: |
          if git tag -v "${GITHUB_REF#refs/tags/}" 2>/dev/null; then
            echo "‚úÖ Tag is signed"
          else
            echo "‚ö†Ô∏è Warning: Tag is not signed (consider signing release tags)"
          fi
        continue-on-error: true

      - name: Install dependencies
        run: npm ci --prefer-offline

      - name: Security audit
        run: npm audit --audit-level=high
        continue-on-error: true

      - name: Build type declarations
        run: npm run build:types

      - name: Build web bundles
        run: npm run build

      - name: Verify build artifacts
        run: |
          echo "üì¶ Checking build artifacts..."
          ls -lh dist/
          echo ""
          echo "üìã Type declarations:"
          find lib -name "*.d.ts" -type f

      - name: Dry-run publish
        run: npm publish --dry-run

      - name: Upload build artifacts
        uses: actions/upload-artifact@v6.0.0
        with:
          name: dist-${{ github.ref_name }}
          path: |
            dist/
            lib/**/*.d.ts
          retention-days: 90

      - name: Publish to npm with provenance
        id: publish
        run: |
          echo "üì§ Publishing to npm..."
          npm publish --provenance --access public
          echo "published=true" >> $GITHUB_OUTPUT
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Verify npm publication
        if: steps.publish.outputs.published == 'true'
        run: |
          PKG_NAME=$(node -p "require('./package.json').name")
          PKG_VERSION=$(node -p "require('./package.json').version")
          echo "üîç Verifying publication..."
          sleep 5  # Wait for npm registry to update
          npm view "$PKG_NAME@$PKG_VERSION" version || echo "‚ö†Ô∏è Package not yet available (may take a few minutes)"

      - name: Create GitHub Release
        id: release
        uses: softprops/action-gh-release@v2.5.0
        with:
          generate_release_notes: true
          files: |
            dist/*.js
            dist/*.js.map
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate job summary
        if: always()
        run: |
          echo "## üì¶ Publish Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | ${{ steps.version.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Tag** | \`${GITHUB_REF#refs/tags/}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${GITHUB_SHA::7}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Published** | ${{ steps.publish.outputs.published == 'true' && '‚úÖ Yes' || '‚ùå No' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release** | ${{ steps.release.outputs.url || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.publish.outputs.published }}" == "true" ]; then
            PKG_NAME=$(node -p "require('./package.json').name")
            echo "### üìã Package Links" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **npm**: https://www.npmjs.com/package/$PKG_NAME/v/${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **unpkg**: https://unpkg.com/$PKG_NAME@${{ steps.version.outputs.version }}/" >> $GITHUB_STEP_SUMMARY
            echo "- **jsDelivr**: https://cdn.jsdelivr.net/npm/$PKG_NAME@${{ steps.version.outputs.version }}/" >> $GITHUB_STEP_SUMMARY
          fi
